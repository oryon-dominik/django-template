# from pathlib import Path

from textual.app import App
from textual.binding import Binding
from textual.containers import VerticalScroll
from textual.widgets import Footer, Header, Placeholder

# from textual.containers import Container, VerticalScroll
# from textual.validation import Function, ValidationResult, Validator
# from textual.widgets import Button, Footer, Header, Static, Input, Label, Pretty, Placeholder
# from textual import on


# CWD = Path(__file__).parent
# ENV_TEMPLATE_PATH = CWD / "envs" / "template.djt"


# def read_template_envs(path: Path = ENV_TEMPLATE_PATH) -> dict[str, str]:
#     """Get environment variables from template."""
#     # TODO: read the envs from doppler or from disk, if available
#     content: list = path.read_text().split("\n")
#     envs: dict = {
#         name: "=".join(values)
#         for line in content
#         for name, *values in [line.split("=")]
#         if line and not line.startswith("#")
#     }
#     return envs


# def is_valid_config_entry(value: str) -> bool:
#     # TODO: validate the value of the config entry, str is not enough
#     try:
#         return str(value) == value
#     except ValueError:
#         return False


# # TBD: class based or function based validators?
# class ValidDjangoSetting(Validator):
#     def validate(self, value: str) -> ValidationResult:
#         """Check validity of django settings modules."""
#         if self.is_valid_setting(value):
#             return self.success()
#         else:
#             return self.failure("That's not a valid django settings module.")

#     @staticmethod
#     def is_valid_setting(value: str) -> bool:
#         return value in [
#             "config.settings.production",
#             "config.settings.develop",
#             "config.settings.test",
#         ]


# class ConfigEntry(Static):
#     """An entry widget for setting environment variables."""

#     def __init__(self, *args, **kwargs) -> None:
#         self.value = kwargs.pop("value")
#         super().__init__(*args, **kwargs)

#     def compose(self):
#         """Create child widgets of a configentry."""
#         yield Container(
#             Label(f"{self.id}"),
#             Input(
#                 placeholder=f"{self.value}",
#                 validate_on=["submitted"],
#                 validators=[
#                     Function(is_valid_config_entry, "Value is not valid."),
#                     ValidDjangoSetting(),  # TODO: add validators for each specific setting
#                 ],
#             ),
#             Pretty([]),
#         )

#     @on(Input.Changed)
#     def show_invalid_reasons(self, event: Input.Changed) -> None:
#         # Updating the UI to show the reasons why validation failed
#         # TODO: implement pretty per entry (query_one is correct?) and style
#         # if not event.validation_result.is_valid:
#         #     self.query_one(Pretty).update(event.validation_result.failure_descriptions)
#         # else:
#         #     self.query_one(Pretty).update([])
#         ...


# class SaveEnvironment(Static):
#     """A widget to save changes in the environment variables."""

#     # TODO: save the envs to disk via action_save_environment
#     # def on_button_pressed(self, event: Button.Pressed) -> None:
#     #     """Event handler called when a button is pressed."""
#     #     if event.button.id == "saved":
#     #         self.add_class("saved")
#     #     elif event.button.id == "modified":  # add an event for editing a field
#     #         self.remove_class("started")

#     def compose(self):
#         """Create child widgets for that Environment."""
#         yield Button("Save", id="save")


# class TerminalUserInterface(App):
#     """A Textual app to manage the doppler config entries."""
#     TITLE = "ENVironment variable settings."
#     SUB_TITLE = "Overriding the values set by doppler."

#     # a file: CSS_PATH = "terminalui.tcss"
#     # TODO: pretty styling
#     CSS = ""

#     BINDINGS = [
#         Binding("ctrl+q,ctrl+x", "quit", "Quit", show=True, priority=True),
#         ("ctrl+s", "save_environment", "Save"),
#         ("d", "toggle_dark", "Dark"),
#     ]

#     def __init__(self, *args, **kwargs) -> None:
#         self.project_environment_variables = read_template_envs()
#         # TODO: choice field for mode (develop, test, production)
#         # TODO: replace {{ stage_name }} with the actual stage name
#         # TODO: pop all predefined envs from the project envs, to add the custom validations for each specific setting
#         # like: self.project_environment_variables.pop("DJANGO_SETTINGS_MODULE")
#         super().__init__(*args, **kwargs)

#     async def action_quit(self):
#         """Quit/Exit the app."""
#         # TODO: save the envs before exiting
#         self.exit(return_code=0, message="Configured the environment variables.")

#     def action_save_environment(self) -> None:
#         """Save the environment."""
#         # TODO: save the envs to disk (or to doppler) -> select which env shall
#         # be used or what developer account to add to the doppler.yaml
#         pass  # pylint: disable=unnecessary-pass

#     def compose(self):
#         """Create child widgets for the app."""
#         yield Header(show_clock=True)
#         yield Container(
#             VerticalScroll(
#                 *[
#                     ConfigEntry(id=f"{env}", value=value, classes=f"env {env.lower()}")
#                     for env, value in self.project_environment_variables.items()
#                 ],  # TODO: manually construct for well known envs, to add custom validators
#                 # ConfigEntry(id="foo", value="bar", classes="foo env"),
#                 id="envcontainer",
#             ),
#             Container(
#                 Pretty(self.project_environment_variables, id="pretty"),
#                 Placeholder(variant="size"),
#                 SaveEnvironment(id="save"),
#                 id="bottomline",
#             ),
#             id="content",
#         )
#         yield Footer()

#     def action_toggle_dark(self) -> None:
#         """An action to toggle dark mode."""
#         self.dark = not self.dark


class TerminalUserInterface(App):
    """A Textual app basic-scaffold."""
    TITLE = "TODO: Terminal UI."
    CSS = "#a { color: red; height: 20%; } #b { height: 30%; } #c { height: 60%; }"
    # CSS_PATH = "terminalui.tcss"

    BINDINGS = [
        Binding("q,x", "quit", "Quit", show=True, priority=True),
        ("d", "toggle_dark", "Dark"),
    ]

    async def action_quit(self):
        """Quit/Exit the app."""
        self.exit(return_code=0, message="Quit.")

    def compose(self):
        """Create child widgets for the app."""
        yield Header(show_clock=True)
        yield VerticalScroll(
            Placeholder(variant="default", id="a"),
            Placeholder(variant="size", id="b"),
            Placeholder(variant="text", id="c"),
            id="content",
        )
        yield Footer()

    def action_toggle_dark(self) -> None:
        """An action to toggle dark mode."""
        self.dark = not self.dark
