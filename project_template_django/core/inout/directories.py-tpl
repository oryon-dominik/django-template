import logging
import os
from pathlib import Path

from . import files


log = logging.getLogger("core.io")

# shall be ROOT_DIR / 'temp'
TEMPORARY_DIRECTORY = Path(__file__).parent.parent.parent / "temp"


def delete_tree(path: Path, panic: bool = True, log_errors: bool = True) -> bool:
    """
    Deletes a folder and all its contents.

    Error handling is done by the closures and the panic flag.
    """
    success = False
    for element in path.iterdir():
        if element.is_dir():
            partial_success = delete_tree(element, panic=panic, log_errors=log_errors)
            if not partial_success and success:
                success = False
        else:
            unlinked = files.unlink(element, panic=panic, log_errors=log_errors)
            if not unlinked and success:
                success = False

    if any(path.iterdir()):
        return False
    deleted = delete_folder(path, panic=panic, log_errors=log_errors)
    return success and deleted


def delete_folder(path: Path, panic: bool = True, log_errors: bool = True) -> bool:  # NOSONAR 19/15 complexity
    """
    Deletes an empty folder.
    """
    success = False
    if not isinstance(path, Path):
        raise TypeError(f"Invalid type for path: {type(path)=}")
    if not path.exists():
        raise FileNotFoundError(f"{path} does not exist.")
    if not path.is_dir():
        raise ValueError(f"{path} is not a directory.")
    if any(path.iterdir()):
        raise ValueError(f"{path} is not empty.")
    try:
        path.rmdir()
        success = True
    except PermissionError as e:
        if log_errors:
            log.error(f"A permission error occurred while deleting the folder: {e}")
        if panic:
            raise e
    except OSError as e:
        if log_errors:
            log.error(f"An OS Error occured while deleting the folder: {e}")
        if panic:
            raise e
    except Exception as e:
        if log_errors:
            log.error(f"An unexpected error occured: {e}")
        if panic:
            raise e
    return success


class TemporaryDirectory:
    """
    A context manager that creates a temporary directory and deletes it
    when exiting the context.

    OS agnostic.
    """

    def __init__(self, directory: Path = TEMPORARY_DIRECTORY, panic: bool = True, log_errors: bool = True) -> None:
        self.panic = panic
        self.log_errors = log_errors
        self.path = directory / os.urandom(24).hex()[:16]

    def __enter__(self):
        self.path.mkdir(parents=True, exist_ok=True)
        return self.path

    def __exit__(self, exc_type, exc_value, traceback):
        try:
            delete_tree(path=self.path, panic=self.panic, log_errors=self.log_errors)
        except OSError as e:
            log.error(f"Error deleting temp-folder: {e}")
            if self.panic:
                raise e
