import logging
import os
from pathlib import Path

from .. import exceptions
from . import files
from . import IO_LOGGER


log = logging.getLogger(IO_LOGGER)

# shall be ROOT_DIR / 'temp'
TEMPORARY_DIRECTORY = Path(__file__).parent.parent.parent / "temp"


def delete_tree(path: Path, keep_parent: bool = False, panic: bool = True, log_errors: bool = True) -> bool:
    """
    Deletes a folder and all its contents.

    Error handling is done by the closures and the panic flag.
    """
    success = False
    for element in path.iterdir():
        if element.is_dir():
            partial_success = delete_tree(element, panic=panic, log_errors=log_errors)
            if not partial_success and success:
                success = False
        else:
            unlinked = files.unlink(element, panic=panic, log_errors=log_errors)
            if not unlinked and success:
                success = False

    if any(path.iterdir()):
        return False
    if not keep_parent:
        deleted = delete_folder(path, panic=panic, log_errors=log_errors)
        return success and deleted
    return success


def delete_folder(path: Path, panic: bool = True, log_errors: bool = True) -> bool:
    """
    Deletes an empty folder.
    """
    success = False

    if not isinstance(path, Path):
        message = f"Invalid type for path: {type(path)=}"
        exc = TypeError(message)
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
        return success

    if not path.exists():
        message = f"{path} does not exist."
        exc = FileNotFoundError(message)
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
        return success

    if not path.is_dir():
        message = f"{path} is not a directory."
        exc = ValueError(message)
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
        return success

    if any(path.iterdir()):
        message = f"{path} is not empty."
        exc = ValueError(message)
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
        return success

    try:
        path.rmdir()
        success = True
    except PermissionError as exc:
        message = f"A permission error occurred while deleting the folder: {exc}"
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
    except OSError as exc:
        message = f"An OS error occurred while deleting the folder: {exc}"
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
    except Exception as exc:
        message = f"An unexpected error occurred: {exc}"
        excpetions.guard(message=message, log_errors=log_errors, logger_name=IO_LOGGER, panic=panic, exc=exc)
    return success


class TemporaryDirectory:
    """
    A context manager that creates a temporary directory and deletes it
    when exiting the context.

    OS agnostic.
    """

    def __init__(self, directory: Path = TEMPORARY_DIRECTORY, panic: bool = True, log_errors: bool = True) -> None:
        self.panic = panic
        self.log_errors = log_errors
        self.path = directory / os.urandom(24).hex()[:16]

    def __enter__(self):
        self.path.mkdir(parents=True, exist_ok=True)
        return self.path

    def __exit__(self, exc_type, exc_value, traceback):
        try:
            delete_tree(path=self.path, panic=self.panic, log_errors=self.log_errors)
        except OSError as exc:
            message = f"Error deleting temp-folder: {exc}"
            excpetions.guard(message=message, log_errors=self.log_errors, logger_name=IO_LOGGER, panic=self.panic, exc=exc)
