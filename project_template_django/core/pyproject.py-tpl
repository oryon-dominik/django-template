from functools import cache
from pathlib import Path
from typing import Any

import git
import msgspec
import tomlkit

from .inout.directories import TemporaryDirectory


class PyProjectTomlLoadException(Exception):
    pass


class PyProjectTomlWriteException(Exception):
    pass


class PyProjectHasBeenSetupBeforeException(Exception):
    pass


class Base(msgspec.Struct, omit_defaults=True, forbid_unknown_fields=True, rename="kebab"):
    """A base class holding some common settings.
    We set ``omit_defaults = True`` to omit any fields containing only their
    default value from the output when encoding.
    - We set ``forbid_unknown_fields = True`` to error nicely if an unknown
    field is present in the input TOML. This helps catch typo errors early,
    and is also required per PEP 621.
    - We set ``rename = "kebab"`` to rename all fields to use kebab case when
    encoding/decoding, as this is the convention used in pyproject.toml. For
    example, this will rename ``requires_python`` to ``requires-python``.
    """

    pass


class BuildSystem(Base):
    requires: list[str] = []
    build_backend: str | None = None
    backend_path: list[str] = []


class Readme(Base):
    file: str | None = None
    text: str | None = None
    content_type: str | None = None


class License(Base):
    file: str | None = None
    text: str | None = None


class Contributor(Base):
    name: str | None = None
    email: str | None = None


class Project(Base):
    name: str | None = None
    version: str | None = None
    description: str | None = None
    readme: str | Readme | None = None
    license: str | License | None = None
    authors: list[Contributor] = []
    maintainers: list[Contributor] = []
    keywords: list[str] = []
    classifiers: list[str] = []
    urls: dict[str, str] = {}
    requires_python: str | None = None
    dependencies: list[str] = []
    optional_dependencies: dict[str, list[str]] = {}
    scripts: dict[str, str] = {}
    gui_scripts: dict[str, str] = {}
    entry_points: dict[str, dict[str, str]] = {}
    dynamic: list[str] = []


class Template(Base):
    repository: str | None = None
    commithash: str | None = None
    latesthash: str | None = None
    templateused: str | None = None


class PyProject(Base):
    build_system: BuildSystem | None = None
    project: Project | None = None
    tool: dict[str, dict[str, Any]] = {}
    template: Template | None = None


@cache
def load_pyproject(project_path: Path) -> PyProject:
    """
    loading pyproject.toml with [msgspec](https://jcristharif.com/msgspec/)
    -> https://jcristharif.com/msgspec/examples/pyproject-toml.html
    """
    content: str = read_pyproject(path=project_path)
    project: PyProject = decode(content)
    return project


def read_pyproject(*, path: Path) -> str:
    """
    Reading the file pyproject.toml
    """
    try:
        with open(path / "pyproject.toml") as file:
            content = file.read()
    except FileNotFoundError:
        raise PyProjectTomlLoadException(f"pyproject.toml not found in {path}")
    except OSError as e:
        raise PyProjectTomlLoadException(f"error while reading pyproject.toml from {path}: {e}")
    return content


def write_pyproject(*, path: Path, content: str) -> None:
    """
    Writing the file pyproject.toml

    """
    try:
        with open(path / "pyproject.toml", "w") as file:
            file.write(content)
    except OSError as e:
        raise PyProjectTomlWriteException(f"error while writing pyproject.toml to {path}: {e}")


def modify_pyproject(*, project_path: Path, modification: dict):
    """
    modifiying pyproject.toml with
    [tomlkit](https://github.com/sdispater/tomlkit) to preserve comments,
    formatting and multiline strings

    """
    content: str = read_pyproject(path=project_path)
    pyproject = tomlkit.parse(content)
    for key, values in modification.items():
        if key not in pyproject:
            table = tomlkit.table()
            pyproject.add(f"{key}", table)
        for subkey, value in values.items():
            pyproject[key][subkey] = value  # type: ignore

    return write_pyproject(path=project_path, content=tomlkit.dumps(pyproject))


def decode(data: bytes | str) -> PyProject:
    """Decode a ``pyproject.toml`` file from TOML"""
    return msgspec.toml.decode(data, type=PyProject)


def encode(msg: PyProject) -> bytes:
    """Encode a ``PyProject`` object to TOML"""
    return msgspec.toml.encode(msg)


def initialize_template_section_to_pyproject(
    *, project_root_path: Path, template_repository_url: str, template_commit_hash: str
):
    """
    initialize template section to pyproject.toml
    """
    project = load_pyproject(project_path=project_root_path)
    if project.template is None:
        raise PyProjectTomlLoadException("Template section is missing.")
    if project.template.latesthash is not None and project.template.commithash is not None:
        raise PyProjectHasBeenSetupBeforeException("Template section is already initialized.")
    return modify_pyproject(
        modification={
            "template": {
                "repository": template_repository_url,
                "commithash": template_commit_hash,
                "latesthash": template_commit_hash,
            }
        },
        project_path=project_root_path,
    )


def get_latest_commit_hash(*, repository_url: str):

    with TemporaryDirectory() as temporary_directory:
        repo = git.Repo.clone_from(repository_url, temporary_directory)  # type: ignore
        latest_commit = repo.head.commit
        commit_hash = latest_commit.hexsha

    return commit_hash


def update_latest_commithash(*, project_root_path: Path, latesthash: str):
    return modify_pyproject(
        modification={
            "template": {
                "latesthash": latesthash,
            }
        },
        project_path=project_root_path,
    )


def cherry_pick_changes(*, pyproject_path):
    """
    cherry pick changes from template repository to the project

    $ git cherry-pick <old_commit_hash>..<latest_commit_hash>
    $ git cherry-pick --continue
    """
    pyproject = load_pyproject(pyproject_path)
    old = pyproject.template.latesthash  # type: ignore
    url = pyproject.template.repository  # type: ignore
    # templateused = pyproject.template.templateused  # type: ignore

    if old is None or url is None:
        raise PyProjectTomlLoadException("Template section is not initialized")

    latest = get_latest_commit_hash(repository_url=url)
    current_repo = git.Repo(pyproject_path)  # type: ignore

    with TemporaryDirectory() as temporary_directory:
        template_repo = git.Repo.clone_from(url, temporary_directory)  # type: ignore
        relevant_changes = list(template_repo.iter_commits(f"{old}..{latest}"))

        # Get the commit messages of the last commits
        commit_message = template_repo.git.log("-n", f"{len(relevant_changes)}", "--pretty=format:%s", latest)
        commit_message = "\n".join(reversed(commit_message.split("\n")))
        # TODOs:
        # - squash all commits into one
        # - throw away all changes except the ones in the template (f"{used_template}") directory
        # - modify all paths and remove f"{used_template}" from the path
        # - modify all paths and replace suffix .py-tpl with .py
        # - replace all occurences of {{ project_name }} with the actual project
        #   name ? what about the other things, django templating engine does?
        #   maybe invoke it here?""

        for commit in relevant_changes:
            ...

            # ideas below:
            ...
            # mv = git.MV(old_path, new_path) ???

            # ????
            # builder = git.TreeBuilder(commit.tree)
            # builder.insert(new_path, mv.rename(old_path))
            # new_tree = builder.write()
            # new_commit = repo.create_commit(
            #     ref=f"refs/heads/{commit.branch.name}",
            #     message=commit.message,
            #     author=commit.author,
            #     committer=commit.committer,
            #     tree=new_tree,
            #     parents=[commit],
            # )

            # ???
            # TODO: git filter-branch --tree-filter "git mv <old_path> <new_path>" <commit_hash>..HEAD
            # filter out everything outside of the project-template directory

        # squashed_commit
        # merge_result = current_repo.git.merge(squashed_commit)
        # print(f">>> DEBUG: {merge_result=}")

        template_repo.close()
        current_repo.close()
    # update_latest_commithash(project_root_path=pyproject_path, latest=latesthash)
